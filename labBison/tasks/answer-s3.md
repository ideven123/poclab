#### 理解规则中嵌入的动作，是继承属性还是综合属性

1. 上述`input`规则中第2行的动作与第5行的动作分别相当于继承属性还是综合属性，Bison对这两个嵌入动作是怎么处理的？请查阅bison生成的`src/exprL.output`进行说明。

   > 答 ： 第二行第五行的动作相当于是综合属性， 即 的lineno 的值不依赖于其右边文法符号的值。BIson的处理，当input 是由 产生式`input： `  分析出的时候，会执行`lineno++；` 指令。而分析完input ，没有结束，又开始分析line时，执行``printf("Line %d (%d):\t", lineno++, @1.last_line);  `

   

2. 根据`./run.sh exprL expr.in`的输出结果，请说明词法分析和语法分析的交替过程，解释输出的第1个行中`3`在`Line 1:`之前的原因。

   >  答 ： 词法分析器由正则表达式`[0-9]+`  识别出 3 之后，先执行了`debug(yytext) ;`  这一步就已经输出了3，之后才有`return(NUMBER); `  而当语法分析独到NUMBER后 ，会进行按产生式`input： `归约  ，然后按照 `@1 : `  归约，这是就开始执行`printf("Line %d (%d):\t", lineno++, @1.last_line)` 了，所以会有3 先输出。 

   

3. 修改`config/exprL-s3.y`，使之能在解析每行前输出行号信息。



#### 使用并理解用Bison构造中缀表达式到逆波兰式的转换

1. 请分析为什么在二义文法下，这里仍能正确输出逆波兰式。

   > 答：  首先该二义文法规定了优先级，和结合性，所以文法遇到冲突时可以按照我们所期望的移进归约顺序计算。
   >
   > 再说为什么是逆波兰式 ： 逆波兰式的特点其实是运算符在操作数后面。那我们以` exp : exp1 PLUS exp2`   为例看一下各部分的输出时机。首先分析的是exp1 ,此时输出第一个表达式（暂且不论是不是逆波兰式），然后分析出PLUS 没有操作，然后分析出exp2输出exp2 ,如果执行归约，则满足了运算符号再操作数后面。这样对每一层exp1 ,exp2 进行递归的分析。可知最终结果就是一个逆波兰式。



#### 分析用Bison构造中缀表达式到波兰式转换中的问题

1. 产生这些冲突的原因；

   > 答： 因为括号里的

2. 为什么还能生成可执行文件`bin/exprL-pre`；

   > 答： 因为生成 。`bin/exprL-pre` 文件的前提是`src/expr.lex.c 和 src/exprL-pre.tab.c` 文件，bison面对移进归约冲突与归约归约冲突有自己的默认处理方式，所以还会生成可知行文件不会报错。但是在分析的过程中就会有出现语法错误的可能。

3. 解释报语法错误的原因。

   > 答： 因为分析器的在面临

   











